// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package tmt2_go

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_tokenScopes          = "bearer_token.Scopes"
	Bearer_token_optionalScopes = "bearer_token_optional.Scopes"
)

// Defines values for ChatEventType.
const (
	ChatEventTypeCHAT ChatEventType = "CHAT"
)

// Defines values for ElectionEndEventType.
const (
	MAPELECTIONEND ElectionEndEventType = "MAP_ELECTION_END"
)

// Defines values for ElectionMapStepType.
const (
	ELECTIONMAPSTEP ElectionMapStepType = "ELECTION_MAP_STEP"
)

// Defines values for ElectionSideStepType.
const (
	ELECTIONSIDESTEP ElectionSideStepType = "ELECTION_SIDE_STEP"
)

// Defines values for IAgreeOrRandomMapMode.
const (
	IAgreeOrRandomMapModeAGREE      IAgreeOrRandomMapMode = "AGREE"
	IAgreeOrRandomMapModeRANDOMPICK IAgreeOrRandomMapMode = "RANDOM_PICK"
)

// Defines values for IBanMapMode.
const (
	BAN IBanMapMode = "BAN"
)

// Defines values for IFixedMapMode.
const (
	IFixedMapModeFIXED IFixedMapMode = "FIXED"
)

// Defines values for IFixedSideMode.
const (
	IFixedSideModeFIXED IFixedSideMode = "FIXED"
)

// Defines values for ILogChatType.
const (
	ILogChatTypeCHAT ILogChatType = "CHAT"
)

// Defines values for ILogSystemType.
const (
	SYSTEM ILogSystemType = "SYSTEM"
)

// Defines values for IMatchUpdateDtoMatchEndAction.
const (
	IMatchUpdateDtoMatchEndActionKICKALL    IMatchUpdateDtoMatchEndAction = "KICK_ALL"
	IMatchUpdateDtoMatchEndActionNONE       IMatchUpdateDtoMatchEndAction = "NONE"
	IMatchUpdateDtoMatchEndActionQUITSERVER IMatchUpdateDtoMatchEndAction = "QUIT_SERVER"
)

// Defines values for IPickMapMode.
const (
	IPickMapModePICK IPickMapMode = "PICK"
)

// Defines values for IPickSideMode.
const (
	IPickSideModePICK IPickSideMode = "PICK"
)

// Defines values for IRandomMapBanMode.
const (
	RANDOMBAN IRandomMapBanMode = "RANDOM_BAN"
)

// Defines values for IRandomOrKnifeSideMode.
const (
	IRandomOrKnifeSideModeKNIFE  IRandomOrKnifeSideMode = "KNIFE"
	IRandomOrKnifeSideModeRANDOM IRandomOrKnifeSideMode = "RANDOM"
)

// Defines values for KnifeRoundEndEventType.
const (
	KNIFEEND KnifeRoundEndEventType = "KNIFE_END"
)

// Defines values for LogEventType.
const (
	LOG LogEventType = "LOG"
)

// Defines values for MapEndEventType.
const (
	MAPEND MapEndEventType = "MAP_END"
)

// Defines values for MapStartEventType.
const (
	MAPSTART MapStartEventType = "MAP_START"
)

// Defines values for MatchCreateEventType.
const (
	MATCHCREATE MatchCreateEventType = "MATCH_CREATE"
)

// Defines values for MatchEndEventType.
const (
	MATCHEND MatchEndEventType = "MATCH_END"
)

// Defines values for MatchUpdateEventType.
const (
	MATCHUPDATE MatchUpdateEventType = "MATCH_UPDATE"
)

// Defines values for RoundEndEventType.
const (
	ROUNDEND RoundEndEventType = "ROUND_END"
)

// Defines values for TElectionState.
const (
	TElectionStateFINISHED   TElectionState = "FINISHED"
	TElectionStateINPROGRESS TElectionState = "IN_PROGRESS"
	TElectionStateNOTSTARTED TElectionState = "NOT_STARTED"
)

// Defines values for TMapMode.
const (
	TMapModeAGREE      TMapMode = "AGREE"
	TMapModeBAN        TMapMode = "BAN"
	TMapModeFIXED      TMapMode = "FIXED"
	TMapModePICK       TMapMode = "PICK"
	TMapModeRANDOMBAN  TMapMode = "RANDOM_BAN"
	TMapModeRANDOMPICK TMapMode = "RANDOM_PICK"
)

// Defines values for TMatchEndAction.
const (
	TMatchEndActionKICKALL    TMatchEndAction = "KICK_ALL"
	TMatchEndActionNONE       TMatchEndAction = "NONE"
	TMatchEndActionQUITSERVER TMatchEndAction = "QUIT_SERVER"
)

// Defines values for TMatchMapSate.
const (
	TMatchMapSateAFTERKNIFE TMatchMapSate = "AFTER_KNIFE"
	TMatchMapSateFINISHED   TMatchMapSate = "FINISHED"
	TMatchMapSateINPROGRESS TMatchMapSate = "IN_PROGRESS"
	TMatchMapSateKNIFE      TMatchMapSate = "KNIFE"
	TMatchMapSateMAPCHANGE  TMatchMapSate = "MAP_CHANGE"
	TMatchMapSatePAUSED     TMatchMapSate = "PAUSED"
	TMatchMapSatePENDING    TMatchMapSate = "PENDING"
	TMatchMapSateWARMUP     TMatchMapSate = "WARMUP"
)

// Defines values for TMatchMode.
const (
	LOOP   TMatchMode = "LOOP"
	SINGLE TMatchMode = "SINGLE"
)

// Defines values for TMatchState.
const (
	TMatchStateELECTION TMatchState = "ELECTION"
	TMatchStateFINISHED TMatchState = "FINISHED"
	TMatchStateMATCHMAP TMatchState = "MATCH_MAP"
)

// Defines values for TSideFixed.
const (
	TEAMACT TSideFixed = "TEAM_A_CT"
	TEAMAT  TSideFixed = "TEAM_A_T"
	TEAMBCT TSideFixed = "TEAM_B_CT"
	TEAMBT  TSideFixed = "TEAM_B_T"
	TEAMXCT TSideFixed = "TEAM_X_CT"
	TEAMXT  TSideFixed = "TEAM_X_T"
	TEAMYCT TSideFixed = "TEAM_Y_CT"
	TEAMYT  TSideFixed = "TEAM_Y_T"
)

// Defines values for TSideMode.
const (
	FIXED  TSideMode = "FIXED"
	KNIFE  TSideMode = "KNIFE"
	PICK   TSideMode = "PICK"
	RANDOM TSideMode = "RANDOM"
)

// Defines values for TStep.
const (
	MAP  TStep = "MAP"
	SIDE TStep = "SIDE"
)

// Defines values for TSystemLogCategory.
const (
	DEBUG TSystemLogCategory = "DEBUG"
	ERROR TSystemLogCategory = "ERROR"
	INFO  TSystemLogCategory = "INFO"
	WARN  TSystemLogCategory = "WARN"
)

// Defines values for TTeamAB.
const (
	TTeamABTEAMA TTeamAB = "TEAM_A"
	TTeamABTEAMB TTeamAB = "TEAM_B"
)

// Defines values for TTeamSides.
const (
	CT TTeamSides = "CT"
	T  TTeamSides = "T"
)

// Defines values for TWho.
const (
	TWhoTEAMA TWho = "TEAM_A"
	TWhoTEAMB TWho = "TEAM_B"
	TWhoTEAMX TWho = "TEAM_X"
	TWhoTEAMY TWho = "TEAM_Y"
)

// ChatEvent defines model for ChatEvent.
type ChatEvent struct {
	IsTeamChat       bool     `json:"isTeamChat"`
	MatchId          string   `json:"matchId"`
	MatchPassthrough *string  `json:"matchPassthrough"`
	Message          string   `json:"message"`
	Player           *IPlayer `json:"player"`
	PlayerTeam       *ITeam   `json:"playerTeam"`
	TeamString       *string  `json:"teamString,omitempty"`

	// Timestamp ISO
	Timestamp string        `json:"timestamp"`
	Type      ChatEventType `json:"type"`
}

// ChatEventType defines model for ChatEvent.Type.
type ChatEventType string

// ElectionEndEvent defines model for ElectionEndEvent.
type ElectionEndEvent struct {
	MapNames         []string `json:"mapNames"`
	MatchId          string   `json:"matchId"`
	MatchPassthrough *string  `json:"matchPassthrough"`

	// Timestamp ISO
	Timestamp string               `json:"timestamp"`
	Type      ElectionEndEventType `json:"type"`
}

// ElectionEndEventType defines model for ElectionEndEvent.Type.
type ElectionEndEventType string

// ElectionMapStep defines model for ElectionMapStep.
type ElectionMapStep struct {
	MapName          string  `json:"mapName"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`

	// Mode Possible map modes for a election step.
	Mode TMapMode `json:"mode"`

	// PickerTeam Team.
	PickerTeam *ITeam `json:"pickerTeam,omitempty"`

	// Timestamp ISO
	Timestamp string              `json:"timestamp"`
	Type      ElectionMapStepType `json:"type"`
}

// ElectionMapStepType defines model for ElectionMapStep.Type.
type ElectionMapStepType string

// ElectionSideStep defines model for ElectionSideStep.
type ElectionSideStep struct {
	// CtTeam Team.
	CtTeam           *ITeam `json:"ctTeam,omitempty"`
	MatchId          string `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`

	// Mode Possible side modes to determine the starting sides of each team.
	Mode       TSideMode   `json:"mode"`
	PickerSide *TTeamSides `json:"pickerSide,omitempty"`

	// PickerTeam Team.
	PickerTeam *ITeam `json:"pickerTeam,omitempty"`

	// TTeam Team.
	TTeam *ITeam `json:"tTeam,omitempty"`

	// Timestamp ISO
	Timestamp string               `json:"timestamp"`
	Type      ElectionSideStepType `json:"type"`
}

// ElectionSideStepType defines model for ElectionSideStep.Type.
type ElectionSideStepType string

// Event defines model for Event.
type Event struct {
	union json.RawMessage
}

// IAgreeOrRandomMap Either pick a random map from the map pool. Or let both teams agree on a map from the map pool.
type IAgreeOrRandomMap struct {
	Mode IAgreeOrRandomMapMode `json:"mode"`
}

// IAgreeOrRandomMapMode defines model for IAgreeOrRandomMap.Mode.
type IAgreeOrRandomMapMode string

// IBanMap Ban a map from the map pool.
type IBanMap struct {
	Mode IBanMapMode `json:"mode"`
	Who  TWho        `json:"who"`
}

// IBanMapMode defines model for IBanMap.Mode.
type IBanMapMode string

// IConfig defines model for IConfig.
type IConfig struct {
	TmtLogAddress *string `json:"tmtLogAddress"`
}

// IElection defines model for IElection.
type IElection struct {
	// CurrentAgree Holds the wanted maps of each team.
	CurrentAgree struct {
		TeamA *string `json:"teamA"`
		TeamB *string `json:"teamB"`
	} `json:"currentAgree"`

	// CurrentRestart The election process can be restarted if both teams vote for it.
	CurrentRestart struct {
		TeamA bool `json:"teamA"`
		TeamB bool `json:"teamB"`
	} `json:"currentRestart"`

	// CurrentStep Index of the current electionSteps of the match.
	CurrentStep float64 `json:"currentStep"`

	// CurrentStepMap Current set map of the current selection step.
	CurrentStepMap *string `json:"currentStepMap,omitempty"`
	CurrentSubStep TStep   `json:"currentSubStep"`

	// RemainingMaps Will be the same as the mapPool from the match, but will shrink when maps get picked, banned or randomly chosen.
	RemainingMaps []string       `json:"remainingMaps"`
	State         TElectionState `json:"state"`
	TeamX         *TTeamAB       `json:"teamX,omitempty"`
	TeamY         *TTeamAB       `json:"teamY,omitempty"`
}

// IElectionStep Election step to either add map to the list of match maps. Or to remove a map from the map pool.
type IElectionStep struct {
	union json.RawMessage
}

// IElectionStepAdd Election steps which will result in a match map that will be played.
type IElectionStepAdd struct {
	Map  IElectionStepAdd_Map  `json:"map"`
	Side IElectionStepAdd_Side `json:"side"`
}

// IElectionStepAdd_Map defines model for IElectionStepAdd.Map.
type IElectionStepAdd_Map struct {
	union json.RawMessage
}

// IElectionStepAdd_Side defines model for IElectionStepAdd.Side.
type IElectionStepAdd_Side struct {
	union json.RawMessage
}

// IElectionStepSkip Election steps which will remove a map from the map pool.
type IElectionStepSkip struct {
	Map IElectionStepSkip_Map `json:"map"`
}

// IElectionStepSkip_Map defines model for IElectionStepSkip.Map.
type IElectionStepSkip_Map struct {
	union json.RawMessage
}

// IFixedMap Play on a fixed map. Map will not be removed from the map pool.
type IFixedMap struct {
	// Fixed The name of the map, e.g. de_anubis.
	Fixed string        `json:"fixed"`
	Mode  IFixedMapMode `json:"mode"`
}

// IFixedMapMode defines model for IFixedMap.Mode.
type IFixedMapMode string

// IFixedSide Use fixed starting sides.
type IFixedSide struct {
	Fixed TSideFixed     `json:"fixed"`
	Mode  IFixedSideMode `json:"mode"`
}

// IFixedSideMode defines model for IFixedSide.Mode.
type IFixedSideMode string

// IGameServer defines model for IGameServer.
type IGameServer struct {
	// HideRconPassword If plebs (client without an admin token) create a match the hideRconPassword attribute is set to true.
	// This will prevent executing rcon commands from the frontend by the (unauthorized) user.
	HideRconPassword *bool   `json:"hideRconPassword,omitempty"`
	Ip               string  `json:"ip"`
	Port             float64 `json:"port"`
	RconPassword     string  `json:"rconPassword"`
}

// ILogChat defines model for ILogChat.
type ILogChat struct {
	IsTeamChat bool         `json:"isTeamChat"`
	Message    string       `json:"message"`
	SteamId64  string       `json:"steamId64"`
	Timestamp float64      `json:"timestamp"`
	Type      ILogChatType `json:"type"`
}

// ILogChatType defines model for ILogChat.Type.
type ILogChatType string

// ILogSystem defines model for ILogSystem.
type ILogSystem struct {
	Category  TSystemLogCategory `json:"category"`
	Message   string             `json:"message"`
	Timestamp float64            `json:"timestamp"`
	Type      ILogSystemType     `json:"type"`
}

// ILogSystemType defines model for ILogSystem.Type.
type ILogSystemType string

// IManagedGameServer defines model for IManagedGameServer.
type IManagedGameServer struct {
	// CanBeUsed Can the server be used for new matches?
	CanBeUsed bool `json:"canBeUsed"`

	// HideRconPassword If plebs (client without an admin token) create a match the hideRconPassword attribute is set to true.
	// This will prevent executing rcon commands from the frontend by the (unauthorized) user.
	HideRconPassword *bool   `json:"hideRconPassword,omitempty"`
	Ip               string  `json:"ip"`
	Port             float64 `json:"port"`
	RconPassword     string  `json:"rconPassword"`

	// UsedBy Match id which is currently using this managed game server.
	UsedBy *string `json:"usedBy"`
}

// IManagedGameServerCreateDto defines model for IManagedGameServerCreateDto.
type IManagedGameServerCreateDto struct {
	// CanBeUsed Can the server be used for new matches?
	CanBeUsed *bool `json:"canBeUsed,omitempty"`

	// HideRconPassword If plebs (client without an admin token) create a match the hideRconPassword attribute is set to true.
	// This will prevent executing rcon commands from the frontend by the (unauthorized) user.
	HideRconPassword *bool   `json:"hideRconPassword,omitempty"`
	Ip               string  `json:"ip"`
	Port             float64 `json:"port"`
	RconPassword     string  `json:"rconPassword"`
}

// IManagedGameServerUpdateDto defines model for IManagedGameServerUpdateDto.
type IManagedGameServerUpdateDto struct {
	// CanBeUsed Set if the server can be used for new matches.
	CanBeUsed    *bool   `json:"canBeUsed,omitempty"`
	Ip           string  `json:"ip"`
	Port         float64 `json:"port"`
	RconPassword *string `json:"rconPassword,omitempty"`

	// UsedBy Set or delete the link to a match. If it's null and `canBeUsed` is true, the game server is available.
	UsedBy *string `json:"usedBy"`
}

// IMatch defines model for IMatch.
type IMatch struct {
	// CanClinch defaults to true, means that possibly not all maps will be played if the winner is determined before
	CanClinch bool `json:"canClinch"`

	// CreatedAt Creation date (unix time in milliseconds since midnight, January 1, 1970 UTC)
	CreatedAt float64 `json:"createdAt"`

	// CurrentMap Index of the matchMaps array indicating the current map.
	CurrentMap float64   `json:"currentMap"`
	Election   IElection `json:"election"`

	// ElectionSteps List of election steps to determine the played map(s).
	ElectionSteps []IElectionStep `json:"electionSteps"`
	GameServer    IGameServer     `json:"gameServer"`

	// Id tmt2 identifier for this match
	Id string `json:"id"`

	// IsStopped If match is finished or if the match was stopped/deleted this is true.
	IsStopped bool `json:"isStopped"`

	// LogSecret Log secret that is given as part of the url to the CS2 server as a log receiver (logaddress_add_http).
	LogSecret string      `json:"logSecret"`
	Logs      []TLogUnion `json:"logs"`

	// MapPool The maps the players can pick or ban.
	// Will also be used if a map is chosen randomly.
	// If the map is fixed it will not be removed from the map pool.
	MapPool        []string        `json:"mapPool"`
	MatchEndAction TMatchEndAction `json:"matchEndAction"`

	// MatchMaps The maps which will be played. If match state is still ELECTION than this is not final.
	MatchMaps []IMatchMap `json:"matchMaps"`

	// Mode Possible match modes.
	Mode TMatchMode `json:"mode"`

	// ParseIncomingLogs Indicates if incoming logs from the CS2 server are parsed (otherwise they will be dropped without any action).
	// Will be set to true if match is loaded from storage (after a short delay).
	ParseIncomingLogs bool `json:"parseIncomingLogs"`

	// Passthrough e.g. remote identifier, will be present in every response/webhook
	Passthrough  *string   `json:"passthrough,omitempty"`
	Players      []IPlayer `json:"players"`
	RconCommands struct {
		// End executed after last match map
		End []string `json:"end"`

		// Init executed exactly once on match init
		Init []string `json:"init"`

		// Knife executed before every knife round
		Knife []string `json:"knife"`

		// Match executed before every match map start
		Match []string `json:"match"`
	} `json:"rconCommands"`

	// ServerPassword Server password, periodically fetched from game server
	ServerPassword string `json:"serverPassword"`

	// State Possible match states.
	State TMatchState `json:"state"`

	// TeamA Team.
	TeamA ITeam `json:"teamA"`

	// TeamB Team.
	TeamB ITeam `json:"teamB"`

	// TmtLogAddress if set will be used to register the target logaddress for the game server
	TmtLogAddress *string `json:"tmtLogAddress,omitempty"`

	// TmtSecret Access token to be used in the API.
	TmtSecret string `json:"tmtSecret"`

	// WebhookUrl if set various events will be posted to this url
	WebhookUrl *string `json:"webhookUrl"`
}

// IMatchCreateDto defines model for IMatchCreateDto.
type IMatchCreateDto struct {
	// CanClinch defaults to true, means that possibly not all maps will be played if the winner is determined before
	CanClinch     *bool                                `json:"canClinch,omitempty"`
	ElectionSteps []IMatchCreateDto_ElectionSteps_Item `json:"electionSteps"`
	GameServer    *IGameServer                         `json:"gameServer"`

	// MapPool The maps the players can pick or ban.
	// Will also be used if a map is chosen randomly.
	// If the map is fixed it will not be removed from the map pool.
	MapPool        []string         `json:"mapPool"`
	MatchEndAction *TMatchEndAction `json:"matchEndAction,omitempty"`

	// Mode Possible match modes.
	Mode *TMatchMode `json:"mode,omitempty"`

	// Passthrough e.g. remote identifier, will be present in every response/webhook
	Passthrough  *string `json:"passthrough,omitempty"`
	RconCommands *struct {
		// End executed after last match map
		End *[]string `json:"end,omitempty"`

		// Init executed exactly once on match init
		Init *[]string `json:"init,omitempty"`

		// Knife executed before every knife round
		Knife *[]string `json:"knife,omitempty"`

		// Match executed before every match map start
		Match *[]string `json:"match,omitempty"`
	} `json:"rconCommands,omitempty"`

	// TeamA Team (create structure).
	TeamA ITeamCreateDto `json:"teamA"`

	// TeamB Team (create structure).
	TeamB ITeamCreateDto `json:"teamB"`

	// TmtLogAddress if set will be used to register the target logaddress for the game server
	TmtLogAddress *string `json:"tmtLogAddress,omitempty"`

	// WebhookUrl if set various events will be posted to this url
	WebhookUrl *string `json:"webhookUrl"`
}

// IMatchCreateDto_ElectionSteps_Item defines model for IMatchCreateDto.electionSteps.Item.
type IMatchCreateDto_ElectionSteps_Item struct {
	union json.RawMessage
}

// IMatchMap defines model for IMatchMap.
type IMatchMap struct {
	KnifeForSide bool `json:"knifeForSide"`
	KnifeRestart struct {
		TeamA bool `json:"teamA"`
		TeamB bool `json:"teamB"`
	} `json:"knifeRestart"`
	KnifeWinner *TTeamAB `json:"knifeWinner,omitempty"`

	// MaxRounds Max rounds (mp_maxrounds).
	MaxRounds float64 `json:"maxRounds"`

	// Name Map name, e.g. de_anubis.
	Name string `json:"name"`

	// OverTimeEnabled If overtime is enabled (mp_overtime_enable).
	OverTimeEnabled bool `json:"overTimeEnabled"`

	// OverTimeMaxRounds Max rounds in overtime (mp_overtime_maxrounds).
	OverTimeMaxRounds float64 `json:"overTimeMaxRounds"`
	ReadyTeams        struct {
		TeamA bool `json:"teamA"`
		TeamB bool `json:"teamB"`
	} `json:"readyTeams"`

	// Score Current score of both teams.
	Score struct {
		TeamA float64 `json:"teamA"`
		TeamB float64 `json:"teamB"`
	} `json:"score"`
	StartAsCtTeam TTeamAB `json:"startAsCtTeam"`

	// State Possible match map states.
	State TMatchMapSate `json:"state"`
}

// IMatchMapUpdateDto Structure to update a match map.
type IMatchMapUpdateDto struct {
	// RefreshOvertimeAndMaxRoundsSettings reads and refreshes mp_overtime_enable, mp_overtime_maxrounds and mp_maxrounds from rcon
	RefreshOvertimeAndMaxRoundsSettings *bool `json:"_refreshOvertimeAndMaxRoundsSettings,omitempty"`

	// SwitchTeamInternals switch team internals, i.e. swap team names (and internal score)
	SwitchTeamInternals *bool `json:"_switchTeamInternals,omitempty"`
	KnifeForSide        *bool `json:"knifeForSide,omitempty"`
	KnifeRestart        *struct {
		TeamA bool `json:"teamA"`
		TeamB bool `json:"teamB"`
	} `json:"knifeRestart,omitempty"`
	KnifeWinner *TTeamAB `json:"knifeWinner,omitempty"`

	// MaxRounds Max rounds (mp_maxrounds).
	MaxRounds *float64 `json:"maxRounds,omitempty"`

	// Name Map name, e.g. de_anubis.
	Name *string `json:"name,omitempty"`

	// OverTimeEnabled If overtime is enabled (mp_overtime_enable).
	OverTimeEnabled *bool `json:"overTimeEnabled,omitempty"`

	// OverTimeMaxRounds Max rounds in overtime (mp_overtime_maxrounds).
	OverTimeMaxRounds *float64 `json:"overTimeMaxRounds,omitempty"`
	ReadyTeams        *struct {
		TeamA bool `json:"teamA"`
		TeamB bool `json:"teamB"`
	} `json:"readyTeams,omitempty"`

	// Score Current score of both teams.
	Score *struct {
		TeamA float64 `json:"teamA"`
		TeamB float64 `json:"teamB"`
	} `json:"score,omitempty"`
	StartAsCtTeam *TTeamAB `json:"startAsCtTeam,omitempty"`

	// State Possible match map states.
	State *TMatchMapSate `json:"state,omitempty"`
}

// IMatchResponse defines model for IMatchResponse.
type IMatchResponse struct {
	// CanClinch defaults to true, means that possibly not all maps will be played if the winner is determined before
	CanClinch bool `json:"canClinch"`

	// CreatedAt Creation date (unix time in milliseconds since midnight, January 1, 1970 UTC)
	CreatedAt float64 `json:"createdAt"`

	// CurrentMap Index of the matchMaps array indicating the current map.
	CurrentMap float64   `json:"currentMap"`
	Election   IElection `json:"election"`

	// ElectionSteps List of election steps to determine the played map(s).
	ElectionSteps []IElectionStep `json:"electionSteps"`
	GameServer    IGameServer     `json:"gameServer"`

	// Id tmt2 identifier for this match
	Id     string `json:"id"`
	IsLive bool   `json:"isLive"`

	// IsStopped If match is finished or if the match was stopped/deleted this is true.
	IsStopped bool `json:"isStopped"`

	// LogSecret Log secret that is given as part of the url to the CS2 server as a log receiver (logaddress_add_http).
	LogSecret string      `json:"logSecret"`
	Logs      []TLogUnion `json:"logs"`

	// MapPool The maps the players can pick or ban.
	// Will also be used if a map is chosen randomly.
	// If the map is fixed it will not be removed from the map pool.
	MapPool        []string        `json:"mapPool"`
	MatchEndAction TMatchEndAction `json:"matchEndAction"`

	// MatchMaps The maps which will be played. If match state is still ELECTION than this is not final.
	MatchMaps []IMatchMap `json:"matchMaps"`

	// Mode Possible match modes.
	Mode TMatchMode `json:"mode"`

	// ParseIncomingLogs Indicates if incoming logs from the CS2 server are parsed (otherwise they will be dropped without any action).
	// Will be set to true if match is loaded from storage (after a short delay).
	ParseIncomingLogs bool `json:"parseIncomingLogs"`

	// Passthrough e.g. remote identifier, will be present in every response/webhook
	Passthrough  *string   `json:"passthrough,omitempty"`
	Players      []IPlayer `json:"players"`
	RconCommands struct {
		// End executed after last match map
		End []string `json:"end"`

		// Init executed exactly once on match init
		Init []string `json:"init"`

		// Knife executed before every knife round
		Knife []string `json:"knife"`

		// Match executed before every match map start
		Match []string `json:"match"`
	} `json:"rconCommands"`

	// ServerPassword Server password, periodically fetched from game server
	ServerPassword string `json:"serverPassword"`

	// State Possible match states.
	State TMatchState `json:"state"`

	// TeamA Team.
	TeamA ITeam `json:"teamA"`

	// TeamB Team.
	TeamB ITeam `json:"teamB"`

	// TmtLogAddress if set will be used to register the target logaddress for the game server
	TmtLogAddress *string `json:"tmtLogAddress,omitempty"`

	// TmtSecret Access token to be used in the API.
	TmtSecret string `json:"tmtSecret"`

	// WebhookUrl if set various events will be posted to this url
	WebhookUrl *string `json:"webhookUrl"`
}

// IMatchUpdateDto defines model for IMatchUpdateDto.
type IMatchUpdateDto struct {
	ExecRconCommandsEnd   *bool `json:"_execRconCommandsEnd,omitempty"`
	ExecRconCommandsInit  *bool `json:"_execRconCommandsInit,omitempty"`
	ExecRconCommandsKnife *bool `json:"_execRconCommandsKnife,omitempty"`
	ExecRconCommandsMatch *bool `json:"_execRconCommandsMatch,omitempty"`
	Init                  *bool `json:"_init,omitempty"`
	RestartElection       *bool `json:"_restartElection,omitempty"`
	Setup                 *bool `json:"_setup,omitempty"`

	// CanClinch defaults to true, means that possibly not all maps will be played if the winner is determined before
	CanClinch     *bool                                 `json:"canClinch,omitempty"`
	CurrentMap    *float64                              `json:"currentMap,omitempty"`
	ElectionSteps *[]IMatchUpdateDto_ElectionSteps_Item `json:"electionSteps,omitempty"`
	GameServer    *IGameServer                          `json:"gameServer,omitempty"`

	// LogSecret updates the server's log address automatically
	LogSecret *string `json:"logSecret,omitempty"`

	// MapPool The maps the players can pick or ban.
	// Will also be used if a map is chosen randomly.
	// If the map is fixed it will not be removed from the map pool.
	MapPool *[]string `json:"mapPool,omitempty"`

	// MatchEndAction defaults to NONE
	MatchEndAction *IMatchUpdateDtoMatchEndAction `json:"matchEndAction,omitempty"`

	// Mode Possible match modes.
	Mode *TMatchMode `json:"mode,omitempty"`

	// Passthrough e.g. remote identifier, will be present in every response/webhook
	Passthrough  *string `json:"passthrough,omitempty"`
	RconCommands *struct {
		End   *[]string `json:"end,omitempty"`
		Init  *[]string `json:"init,omitempty"`
		Knife *[]string `json:"knife,omitempty"`
		Match *[]string `json:"match,omitempty"`
	} `json:"rconCommands,omitempty"`

	// State Possible match states.
	State *TMatchState `json:"state,omitempty"`

	// TeamA Team (create structure).
	TeamA *ITeamCreateDto `json:"teamA,omitempty"`

	// TeamB Team (create structure).
	TeamB *ITeamCreateDto `json:"teamB,omitempty"`

	// TmtLogAddress if set will be used to register the target logaddress for the game server
	TmtLogAddress *string `json:"tmtLogAddress,omitempty"`

	// WebhookUrl if set various events will be posted to this url
	WebhookUrl *string `json:"webhookUrl,omitempty"`
}

// IMatchUpdateDto_ElectionSteps_Item defines model for IMatchUpdateDto.electionSteps.Item.
type IMatchUpdateDto_ElectionSteps_Item struct {
	union json.RawMessage
}

// IMatchUpdateDtoMatchEndAction defaults to NONE
type IMatchUpdateDtoMatchEndAction string

// IPickMap Pick a map from the map pool.
type IPickMap struct {
	Mode IPickMapMode `json:"mode"`
	Who  TWho         `json:"who"`
}

// IPickMapMode defines model for IPickMap.Mode.
type IPickMapMode string

// IPickSide Let one team choose its starting side.
type IPickSide struct {
	Mode IPickSideMode `json:"mode"`
	Who  TWho          `json:"who"`
}

// IPickSideMode defines model for IPickSide.Mode.
type IPickSideMode string

// IPlayer Player.
type IPlayer struct {
	// Name Name.
	Name string `json:"name"`

	// Online Player currently on the game server (online)?
	Online *bool `json:"online,omitempty"`

	// Side Current ingame side.
	Side *TTeamSides `json:"side"`

	// SteamId64 Steam ID 64
	SteamId64 string   `json:"steamId64"`
	Team      *TTeamAB `json:"team,omitempty"`
}

// IPreset defines model for IPreset.
type IPreset struct {
	Data IMatchCreateDto `json:"data"`
	Id   string          `json:"id"`
	Name string          `json:"name"`
}

// IPresetCreateDto defines model for IPresetCreateDto.
type IPresetCreateDto struct {
	Data IMatchCreateDto `json:"data"`
	Name string          `json:"name"`
}

// IRandomMapBan Randomly ban a map from the map pool.
type IRandomMapBan struct {
	Mode IRandomMapBanMode `json:"mode"`
}

// IRandomMapBanMode defines model for IRandomMapBan.Mode.
type IRandomMapBanMode string

// IRandomOrKnifeSide Either randomly set starting sides. Or do a knife round befor the map starts and let the winner decide.
type IRandomOrKnifeSide struct {
	Mode IRandomOrKnifeSideMode `json:"mode"`
}

// IRandomOrKnifeSideMode defines model for IRandomOrKnifeSide.Mode.
type IRandomOrKnifeSideMode string

// ITeam Team.
type ITeam struct {
	// Advantage Advantage in map wins, useful for double elemination tournament finals.
	Advantage float64 `json:"advantage"`

	// Name Team name.
	Name string `json:"name"`

	// Passthrough Passthrough data to identify team in other systems.
	// Will be present in every response/webhook.
	Passthrough *string `json:"passthrough,omitempty"`
}

// ITeamCreateDto Team (create structure).
type ITeamCreateDto struct {
	// Advantage Advantage in map wins, useful for double elemination tournament finals.
	Advantage *float64 `json:"advantage,omitempty"`
	Name      string   `json:"name"`

	// Passthrough Passthrough data to identify team in other systems.
	// Will be present in every response/webhook.
	Passthrough *string `json:"passthrough,omitempty"`
}

// KnifeRoundEndEvent defines model for KnifeRoundEndEvent.
type KnifeRoundEndEvent struct {
	MapIndex         float64 `json:"mapIndex"`
	MapName          string  `json:"mapName"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`

	// Timestamp ISO
	Timestamp string                 `json:"timestamp"`
	Type      KnifeRoundEndEventType `json:"type"`

	// WinnerTeam Team.
	WinnerTeam ITeam `json:"winnerTeam"`
}

// KnifeRoundEndEventType defines model for KnifeRoundEndEvent.Type.
type KnifeRoundEndEventType string

// LogEvent defines model for LogEvent.
type LogEvent struct {
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`
	Message          string  `json:"message"`

	// Timestamp ISO
	Timestamp string       `json:"timestamp"`
	Type      LogEventType `json:"type"`
}

// LogEventType defines model for LogEvent.Type.
type LogEventType string

// MapEndEvent defines model for MapEndEvent.
type MapEndEvent struct {
	MapIndex         float64 `json:"mapIndex"`
	MapName          string  `json:"mapName"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`
	ScoreTeamA       float64 `json:"scoreTeamA"`
	ScoreTeamB       float64 `json:"scoreTeamB"`

	// Timestamp ISO
	Timestamp string          `json:"timestamp"`
	Type      MapEndEventType `json:"type"`

	// WinnerTeam winner of the match or null if it's a draw
	WinnerTeam *ITeam `json:"winnerTeam"`
}

// MapEndEventType defines model for MapEndEvent.Type.
type MapEndEventType string

// MapStartEvent defines model for MapStartEvent.
type MapStartEvent struct {
	MapIndex         float64 `json:"mapIndex"`
	MapName          string  `json:"mapName"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`

	// Timestamp ISO
	Timestamp string            `json:"timestamp"`
	Type      MapStartEventType `json:"type"`
}

// MapStartEventType defines model for MapStartEvent.Type.
type MapStartEventType string

// MatchCreateEvent defines model for MatchCreateEvent.
type MatchCreateEvent struct {
	Match   IMatchResponse `json:"match"`
	MatchId string         `json:"matchId"`
	MatchPassthrough *string        `json:"matchPassthrough"`

	// Timestamp ISO
	Timestamp string               `json:"timestamp"`
	Type      MatchCreateEventType `json:"type"`
}

// MatchCreateEventType defines model for MatchCreateEvent.Type.
type MatchCreateEventType string

// MatchEndEvent defines model for MatchEndEvent.
type MatchEndEvent struct {
	MapResults []struct {
		MapName    string  `json:"mapName"`
		ScoreTeamA float64 `json:"scoreTeamA"`
		ScoreTeamB float64 `json:"scoreTeamB"`

		// WinnerTeam winner of the match or null if it's a draw
		WinnerTeam *ITeam `json:"winnerTeam"`
	} `json:"mapResults"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`

	// Timestamp ISO
	Timestamp string            `json:"timestamp"`
	Type      MatchEndEventType `json:"type"`

	// WinnerTeam winner of the match or null if it's a draw
	WinnerTeam   *ITeam  `json:"winnerTeam"`
	WonMapsTeamA float64 `json:"wonMapsTeamA"`
	WonMapsTeamB float64 `json:"wonMapsTeamB"`
}

// MatchEndEventType defines model for MatchEndEvent.Type.
type MatchEndEventType string

// MatchUpdateEvent defines model for MatchUpdateEvent.
type MatchUpdateEvent struct {
	MatchId          string                       `json:"matchId"`
	MatchPassthrough *string                      `json:"matchPassthrough"`
	Path             []MatchUpdateEvent_Path_Item `json:"path"`

	// Timestamp ISO
	Timestamp string               `json:"timestamp"`
	Type      MatchUpdateEventType `json:"type"`
	Value     interface{}          `json:"value"`
}

// MatchUpdateEventPath0 defines model for .
type MatchUpdateEventPath0 = string

// MatchUpdateEventPath1 defines model for .
type MatchUpdateEventPath1 = float64

// MatchUpdateEvent_Path_Item defines model for MatchUpdateEvent.path.Item.
type MatchUpdateEvent_Path_Item struct {
	union json.RawMessage
}

// MatchUpdateEventType defines model for MatchUpdateEvent.Type.
type MatchUpdateEventType string

// RoundEndEvent defines model for RoundEndEvent.
type RoundEndEvent struct {
	MapIndex         float64 `json:"mapIndex"`
	MapName          string  `json:"mapName"`
	MatchId          string  `json:"matchId"`
	MatchPassthrough *string `json:"matchPassthrough"`
	ScoreTeamA       float64 `json:"scoreTeamA"`
	ScoreTeamB       float64 `json:"scoreTeamB"`

	// Timestamp ISO
	Timestamp string            `json:"timestamp"`
	Type      RoundEndEventType `json:"type"`

	// WinnerTeam Team.
	WinnerTeam ITeam `json:"winnerTeam"`
}

// RoundEndEventType defines model for RoundEndEvent.Type.
type RoundEndEventType string

// TElectionState defines model for TElectionState.
type TElectionState string

// TLogUnion defines model for TLogUnion.
type TLogUnion struct {
	union json.RawMessage
}

// TMapMode Possible map modes for a election step.
type TMapMode string

// TMatchEndAction defines model for TMatchEndAction.
type TMatchEndAction string

// TMatchMapSate Possible match map states.
type TMatchMapSate string

// TMatchMode Possible match modes.
type TMatchMode string

// TMatchState Possible match states.
type TMatchState string

// TSideFixed defines model for TSideFixed.
type TSideFixed string

// TSideMode Possible side modes to determine the starting sides of each team.
type TSideMode string

// TStep defines model for TStep.
type TStep string

// TSystemLogCategory defines model for TSystemLogCategory.
type TSystemLogCategory string

// TTeamAB defines model for TTeamAB.
type TTeamAB string

// TTeamSides defines model for TTeamSides.
type TTeamSides string

// TWho defines model for TWho.
type TWho string

// GetAllMatchesParams defines parameters for GetAllMatches.
type GetAllMatchesParams struct {
	// State State filter
	State *[]string `form:"state,omitempty" json:"state,omitempty"`

	// Passthrough Passthrough filter
	Passthrough *[]string `form:"passthrough,omitempty" json:"passthrough,omitempty"`

	// IsStopped Get only stopped or not stopped matches.
	IsStopped *bool `form:"isStopped,omitempty" json:"isStopped,omitempty"`

	// IsLive Filter for only live (currently active) matches, or the opposite.
	IsLive *bool `form:"isLive,omitempty" json:"isLive,omitempty"`
}

// ReceiveLogJSONBody defines parameters for ReceiveLog.
type ReceiveLogJSONBody = interface{}

// RconJSONBody defines parameters for Rcon.
type RconJSONBody = []string

// GetRoundBackupsParams defines parameters for GetRoundBackups.
type GetRoundBackupsParams struct {
	// Count The max. number of round backups to be returned.
	Count *float64 `form:"count,omitempty" json:"count,omitempty"`
}

// CreateGameServerJSONRequestBody defines body for CreateGameServer for application/json ContentType.
type CreateGameServerJSONRequestBody = IManagedGameServerCreateDto

// UpdateGameServerJSONRequestBody defines body for UpdateGameServer for application/json ContentType.
type UpdateGameServerJSONRequestBody = IManagedGameServerUpdateDto

// CreateMatchJSONRequestBody defines body for CreateMatch for application/json ContentType.
type CreateMatchJSONRequestBody = IMatchCreateDto

// UpdateMatchJSONRequestBody defines body for UpdateMatch for application/json ContentType.
type UpdateMatchJSONRequestBody = IMatchUpdateDto

// UpdateMatchMapJSONRequestBody defines body for UpdateMatchMap for application/json ContentType.
type UpdateMatchMapJSONRequestBody = IMatchMapUpdateDto

// ReceiveLogJSONRequestBody defines body for ReceiveLog for application/json ContentType.
type ReceiveLogJSONRequestBody = ReceiveLogJSONBody

// RconJSONRequestBody defines body for Rcon for application/json ContentType.
type RconJSONRequestBody = RconJSONBody

// CreatePresetJSONRequestBody defines body for CreatePreset for application/json ContentType.
type CreatePresetJSONRequestBody = IPresetCreateDto

// UpdatePresetJSONRequestBody defines body for UpdatePreset for application/json ContentType.
type UpdatePresetJSONRequestBody = IPreset

// AsChatEvent returns the union data inside the Event as a ChatEvent
func (t Event) AsChatEvent() (ChatEvent, error) {
	var body ChatEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChatEvent overwrites any union data inside the Event as the provided ChatEvent
func (t *Event) FromChatEvent(v ChatEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChatEvent performs a merge with any union data inside the Event, using the provided ChatEvent
func (t *Event) MergeChatEvent(v ChatEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElectionEndEvent returns the union data inside the Event as a ElectionEndEvent
func (t Event) AsElectionEndEvent() (ElectionEndEvent, error) {
	var body ElectionEndEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElectionEndEvent overwrites any union data inside the Event as the provided ElectionEndEvent
func (t *Event) FromElectionEndEvent(v ElectionEndEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElectionEndEvent performs a merge with any union data inside the Event, using the provided ElectionEndEvent
func (t *Event) MergeElectionEndEvent(v ElectionEndEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRoundEndEvent returns the union data inside the Event as a RoundEndEvent
func (t Event) AsRoundEndEvent() (RoundEndEvent, error) {
	var body RoundEndEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRoundEndEvent overwrites any union data inside the Event as the provided RoundEndEvent
func (t *Event) FromRoundEndEvent(v RoundEndEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRoundEndEvent performs a merge with any union data inside the Event, using the provided RoundEndEvent
func (t *Event) MergeRoundEndEvent(v RoundEndEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapEndEvent returns the union data inside the Event as a MapEndEvent
func (t Event) AsMapEndEvent() (MapEndEvent, error) {
	var body MapEndEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapEndEvent overwrites any union data inside the Event as the provided MapEndEvent
func (t *Event) FromMapEndEvent(v MapEndEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapEndEvent performs a merge with any union data inside the Event, using the provided MapEndEvent
func (t *Event) MergeMapEndEvent(v MapEndEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchEndEvent returns the union data inside the Event as a MatchEndEvent
func (t Event) AsMatchEndEvent() (MatchEndEvent, error) {
	var body MatchEndEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchEndEvent overwrites any union data inside the Event as the provided MatchEndEvent
func (t *Event) FromMatchEndEvent(v MatchEndEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchEndEvent performs a merge with any union data inside the Event, using the provided MatchEndEvent
func (t *Event) MergeMatchEndEvent(v MatchEndEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKnifeRoundEndEvent returns the union data inside the Event as a KnifeRoundEndEvent
func (t Event) AsKnifeRoundEndEvent() (KnifeRoundEndEvent, error) {
	var body KnifeRoundEndEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKnifeRoundEndEvent overwrites any union data inside the Event as the provided KnifeRoundEndEvent
func (t *Event) FromKnifeRoundEndEvent(v KnifeRoundEndEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKnifeRoundEndEvent performs a merge with any union data inside the Event, using the provided KnifeRoundEndEvent
func (t *Event) MergeKnifeRoundEndEvent(v KnifeRoundEndEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMapStartEvent returns the union data inside the Event as a MapStartEvent
func (t Event) AsMapStartEvent() (MapStartEvent, error) {
	var body MapStartEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMapStartEvent overwrites any union data inside the Event as the provided MapStartEvent
func (t *Event) FromMapStartEvent(v MapStartEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMapStartEvent performs a merge with any union data inside the Event, using the provided MapStartEvent
func (t *Event) MergeMapStartEvent(v MapStartEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLogEvent returns the union data inside the Event as a LogEvent
func (t Event) AsLogEvent() (LogEvent, error) {
	var body LogEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLogEvent overwrites any union data inside the Event as the provided LogEvent
func (t *Event) FromLogEvent(v LogEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLogEvent performs a merge with any union data inside the Event, using the provided LogEvent
func (t *Event) MergeLogEvent(v LogEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElectionMapStep returns the union data inside the Event as a ElectionMapStep
func (t Event) AsElectionMapStep() (ElectionMapStep, error) {
	var body ElectionMapStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElectionMapStep overwrites any union data inside the Event as the provided ElectionMapStep
func (t *Event) FromElectionMapStep(v ElectionMapStep) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElectionMapStep performs a merge with any union data inside the Event, using the provided ElectionMapStep
func (t *Event) MergeElectionMapStep(v ElectionMapStep) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsElectionSideStep returns the union data inside the Event as a ElectionSideStep
func (t Event) AsElectionSideStep() (ElectionSideStep, error) {
	var body ElectionSideStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromElectionSideStep overwrites any union data inside the Event as the provided ElectionSideStep
func (t *Event) FromElectionSideStep(v ElectionSideStep) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeElectionSideStep performs a merge with any union data inside the Event, using the provided ElectionSideStep
func (t *Event) MergeElectionSideStep(v ElectionSideStep) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchCreateEvent returns the union data inside the Event as a MatchCreateEvent
func (t Event) AsMatchCreateEvent() (MatchCreateEvent, error) {
	var body MatchCreateEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchCreateEvent overwrites any union data inside the Event as the provided MatchCreateEvent
func (t *Event) FromMatchCreateEvent(v MatchCreateEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchCreateEvent performs a merge with any union data inside the Event, using the provided MatchCreateEvent
func (t *Event) MergeMatchCreateEvent(v MatchCreateEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchUpdateEvent returns the union data inside the Event as a MatchUpdateEvent
func (t Event) AsMatchUpdateEvent() (MatchUpdateEvent, error) {
	var body MatchUpdateEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchUpdateEvent overwrites any union data inside the Event as the provided MatchUpdateEvent
func (t *Event) FromMatchUpdateEvent(v MatchUpdateEvent) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchUpdateEvent performs a merge with any union data inside the Event, using the provided MatchUpdateEvent
func (t *Event) MergeMatchUpdateEvent(v MatchUpdateEvent) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIElectionStepAdd returns the union data inside the IElectionStep as a IElectionStepAdd
func (t IElectionStep) AsIElectionStepAdd() (IElectionStepAdd, error) {
	var body IElectionStepAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepAdd overwrites any union data inside the IElectionStep as the provided IElectionStepAdd
func (t *IElectionStep) FromIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepAdd performs a merge with any union data inside the IElectionStep, using the provided IElectionStepAdd
func (t *IElectionStep) MergeIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIElectionStepSkip returns the union data inside the IElectionStep as a IElectionStepSkip
func (t IElectionStep) AsIElectionStepSkip() (IElectionStepSkip, error) {
	var body IElectionStepSkip
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepSkip overwrites any union data inside the IElectionStep as the provided IElectionStepSkip
func (t *IElectionStep) FromIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepSkip performs a merge with any union data inside the IElectionStep, using the provided IElectionStepSkip
func (t *IElectionStep) MergeIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IElectionStep) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IElectionStep) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIFixedMap returns the union data inside the IElectionStepAdd_Map as a IFixedMap
func (t IElectionStepAdd_Map) AsIFixedMap() (IFixedMap, error) {
	var body IFixedMap
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIFixedMap overwrites any union data inside the IElectionStepAdd_Map as the provided IFixedMap
func (t *IElectionStepAdd_Map) FromIFixedMap(v IFixedMap) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIFixedMap performs a merge with any union data inside the IElectionStepAdd_Map, using the provided IFixedMap
func (t *IElectionStepAdd_Map) MergeIFixedMap(v IFixedMap) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIPickMap returns the union data inside the IElectionStepAdd_Map as a IPickMap
func (t IElectionStepAdd_Map) AsIPickMap() (IPickMap, error) {
	var body IPickMap
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIPickMap overwrites any union data inside the IElectionStepAdd_Map as the provided IPickMap
func (t *IElectionStepAdd_Map) FromIPickMap(v IPickMap) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIPickMap performs a merge with any union data inside the IElectionStepAdd_Map, using the provided IPickMap
func (t *IElectionStepAdd_Map) MergeIPickMap(v IPickMap) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIAgreeOrRandomMap returns the union data inside the IElectionStepAdd_Map as a IAgreeOrRandomMap
func (t IElectionStepAdd_Map) AsIAgreeOrRandomMap() (IAgreeOrRandomMap, error) {
	var body IAgreeOrRandomMap
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIAgreeOrRandomMap overwrites any union data inside the IElectionStepAdd_Map as the provided IAgreeOrRandomMap
func (t *IElectionStepAdd_Map) FromIAgreeOrRandomMap(v IAgreeOrRandomMap) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIAgreeOrRandomMap performs a merge with any union data inside the IElectionStepAdd_Map, using the provided IAgreeOrRandomMap
func (t *IElectionStepAdd_Map) MergeIAgreeOrRandomMap(v IAgreeOrRandomMap) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IElectionStepAdd_Map) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IElectionStepAdd_Map) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIFixedSide returns the union data inside the IElectionStepAdd_Side as a IFixedSide
func (t IElectionStepAdd_Side) AsIFixedSide() (IFixedSide, error) {
	var body IFixedSide
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIFixedSide overwrites any union data inside the IElectionStepAdd_Side as the provided IFixedSide
func (t *IElectionStepAdd_Side) FromIFixedSide(v IFixedSide) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIFixedSide performs a merge with any union data inside the IElectionStepAdd_Side, using the provided IFixedSide
func (t *IElectionStepAdd_Side) MergeIFixedSide(v IFixedSide) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIPickSide returns the union data inside the IElectionStepAdd_Side as a IPickSide
func (t IElectionStepAdd_Side) AsIPickSide() (IPickSide, error) {
	var body IPickSide
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIPickSide overwrites any union data inside the IElectionStepAdd_Side as the provided IPickSide
func (t *IElectionStepAdd_Side) FromIPickSide(v IPickSide) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIPickSide performs a merge with any union data inside the IElectionStepAdd_Side, using the provided IPickSide
func (t *IElectionStepAdd_Side) MergeIPickSide(v IPickSide) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIRandomOrKnifeSide returns the union data inside the IElectionStepAdd_Side as a IRandomOrKnifeSide
func (t IElectionStepAdd_Side) AsIRandomOrKnifeSide() (IRandomOrKnifeSide, error) {
	var body IRandomOrKnifeSide
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIRandomOrKnifeSide overwrites any union data inside the IElectionStepAdd_Side as the provided IRandomOrKnifeSide
func (t *IElectionStepAdd_Side) FromIRandomOrKnifeSide(v IRandomOrKnifeSide) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIRandomOrKnifeSide performs a merge with any union data inside the IElectionStepAdd_Side, using the provided IRandomOrKnifeSide
func (t *IElectionStepAdd_Side) MergeIRandomOrKnifeSide(v IRandomOrKnifeSide) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IElectionStepAdd_Side) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IElectionStepAdd_Side) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIRandomMapBan returns the union data inside the IElectionStepSkip_Map as a IRandomMapBan
func (t IElectionStepSkip_Map) AsIRandomMapBan() (IRandomMapBan, error) {
	var body IRandomMapBan
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIRandomMapBan overwrites any union data inside the IElectionStepSkip_Map as the provided IRandomMapBan
func (t *IElectionStepSkip_Map) FromIRandomMapBan(v IRandomMapBan) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIRandomMapBan performs a merge with any union data inside the IElectionStepSkip_Map, using the provided IRandomMapBan
func (t *IElectionStepSkip_Map) MergeIRandomMapBan(v IRandomMapBan) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIBanMap returns the union data inside the IElectionStepSkip_Map as a IBanMap
func (t IElectionStepSkip_Map) AsIBanMap() (IBanMap, error) {
	var body IBanMap
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIBanMap overwrites any union data inside the IElectionStepSkip_Map as the provided IBanMap
func (t *IElectionStepSkip_Map) FromIBanMap(v IBanMap) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIBanMap performs a merge with any union data inside the IElectionStepSkip_Map, using the provided IBanMap
func (t *IElectionStepSkip_Map) MergeIBanMap(v IBanMap) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IElectionStepSkip_Map) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IElectionStepSkip_Map) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIElectionStepAdd returns the union data inside the IMatchCreateDto_ElectionSteps_Item as a IElectionStepAdd
func (t IMatchCreateDto_ElectionSteps_Item) AsIElectionStepAdd() (IElectionStepAdd, error) {
	var body IElectionStepAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepAdd overwrites any union data inside the IMatchCreateDto_ElectionSteps_Item as the provided IElectionStepAdd
func (t *IMatchCreateDto_ElectionSteps_Item) FromIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepAdd performs a merge with any union data inside the IMatchCreateDto_ElectionSteps_Item, using the provided IElectionStepAdd
func (t *IMatchCreateDto_ElectionSteps_Item) MergeIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIElectionStepSkip returns the union data inside the IMatchCreateDto_ElectionSteps_Item as a IElectionStepSkip
func (t IMatchCreateDto_ElectionSteps_Item) AsIElectionStepSkip() (IElectionStepSkip, error) {
	var body IElectionStepSkip
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepSkip overwrites any union data inside the IMatchCreateDto_ElectionSteps_Item as the provided IElectionStepSkip
func (t *IMatchCreateDto_ElectionSteps_Item) FromIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepSkip performs a merge with any union data inside the IMatchCreateDto_ElectionSteps_Item, using the provided IElectionStepSkip
func (t *IMatchCreateDto_ElectionSteps_Item) MergeIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IMatchCreateDto_ElectionSteps_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IMatchCreateDto_ElectionSteps_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIElectionStepAdd returns the union data inside the IMatchUpdateDto_ElectionSteps_Item as a IElectionStepAdd
func (t IMatchUpdateDto_ElectionSteps_Item) AsIElectionStepAdd() (IElectionStepAdd, error) {
	var body IElectionStepAdd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepAdd overwrites any union data inside the IMatchUpdateDto_ElectionSteps_Item as the provided IElectionStepAdd
func (t *IMatchUpdateDto_ElectionSteps_Item) FromIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepAdd performs a merge with any union data inside the IMatchUpdateDto_ElectionSteps_Item, using the provided IElectionStepAdd
func (t *IMatchUpdateDto_ElectionSteps_Item) MergeIElectionStepAdd(v IElectionStepAdd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIElectionStepSkip returns the union data inside the IMatchUpdateDto_ElectionSteps_Item as a IElectionStepSkip
func (t IMatchUpdateDto_ElectionSteps_Item) AsIElectionStepSkip() (IElectionStepSkip, error) {
	var body IElectionStepSkip
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIElectionStepSkip overwrites any union data inside the IMatchUpdateDto_ElectionSteps_Item as the provided IElectionStepSkip
func (t *IMatchUpdateDto_ElectionSteps_Item) FromIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIElectionStepSkip performs a merge with any union data inside the IMatchUpdateDto_ElectionSteps_Item, using the provided IElectionStepSkip
func (t *IMatchUpdateDto_ElectionSteps_Item) MergeIElectionStepSkip(v IElectionStepSkip) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IMatchUpdateDto_ElectionSteps_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IMatchUpdateDto_ElectionSteps_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMatchUpdateEventPath0 returns the union data inside the MatchUpdateEvent_Path_Item as a MatchUpdateEventPath0
func (t MatchUpdateEvent_Path_Item) AsMatchUpdateEventPath0() (MatchUpdateEventPath0, error) {
	var body MatchUpdateEventPath0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchUpdateEventPath0 overwrites any union data inside the MatchUpdateEvent_Path_Item as the provided MatchUpdateEventPath0
func (t *MatchUpdateEvent_Path_Item) FromMatchUpdateEventPath0(v MatchUpdateEventPath0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchUpdateEventPath0 performs a merge with any union data inside the MatchUpdateEvent_Path_Item, using the provided MatchUpdateEventPath0
func (t *MatchUpdateEvent_Path_Item) MergeMatchUpdateEventPath0(v MatchUpdateEventPath0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMatchUpdateEventPath1 returns the union data inside the MatchUpdateEvent_Path_Item as a MatchUpdateEventPath1
func (t MatchUpdateEvent_Path_Item) AsMatchUpdateEventPath1() (MatchUpdateEventPath1, error) {
	var body MatchUpdateEventPath1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMatchUpdateEventPath1 overwrites any union data inside the MatchUpdateEvent_Path_Item as the provided MatchUpdateEventPath1
func (t *MatchUpdateEvent_Path_Item) FromMatchUpdateEventPath1(v MatchUpdateEventPath1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMatchUpdateEventPath1 performs a merge with any union data inside the MatchUpdateEvent_Path_Item, using the provided MatchUpdateEventPath1
func (t *MatchUpdateEvent_Path_Item) MergeMatchUpdateEventPath1(v MatchUpdateEventPath1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MatchUpdateEvent_Path_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MatchUpdateEvent_Path_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsILogChat returns the union data inside the TLogUnion as a ILogChat
func (t TLogUnion) AsILogChat() (ILogChat, error) {
	var body ILogChat
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromILogChat overwrites any union data inside the TLogUnion as the provided ILogChat
func (t *TLogUnion) FromILogChat(v ILogChat) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeILogChat performs a merge with any union data inside the TLogUnion, using the provided ILogChat
func (t *TLogUnion) MergeILogChat(v ILogChat) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsILogSystem returns the union data inside the TLogUnion as a ILogSystem
func (t TLogUnion) AsILogSystem() (ILogSystem, error) {
	var body ILogSystem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromILogSystem overwrites any union data inside the TLogUnion as the provided ILogSystem
func (t *TLogUnion) FromILogSystem(v ILogSystem) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeILogSystem performs a merge with any union data inside the TLogUnion, using the provided ILogSystem
func (t *TLogUnion) MergeILogSystem(v ILogSystem) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TLogUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TLogUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfos request
	GetInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebSocketClients request
	GetWebSocketClients(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameServers request
	GetGameServers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGameServerWithBody request with any body
	CreateGameServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGameServer(ctx context.Context, body CreateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGameServer request
	DeleteGameServer(ctx context.Context, ip string, port float64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGameServerWithBody request with any body
	UpdateGameServerWithBody(ctx context.Context, ip string, port float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGameServer(ctx context.Context, ip string, port float64, body UpdateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request
	Login(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllMatches request
	GetAllMatches(ctx context.Context, params *GetAllMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMatchWithBody request with any body
	CreateMatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMatch(ctx context.Context, body CreateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMatch request
	DeleteMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMatch request
	GetMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMatchWithBody request with any body
	UpdateMatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMatch(ctx context.Context, id string, body UpdateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogs request
	GetLogs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMatchMapWithBody request with any body
	UpdateMatchMapWithBody(ctx context.Context, id string, mapNumber float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMatchMap(ctx context.Context, id string, mapNumber float64, body UpdateMatchMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviveMatch request
	ReviveMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveLogWithBody request with any body
	ReceiveLogWithBody(ctx context.Context, id string, secret string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReceiveLog(ctx context.Context, id string, secret string, body ReceiveLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RconWithBody request with any body
	RconWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Rcon(ctx context.Context, id string, body RconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoundBackups request
	GetRoundBackups(ctx context.Context, id string, params *GetRoundBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadRoundBackup request
	LoadRoundBackup(ctx context.Context, id string, file string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPresets request
	GetPresets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePresetWithBody request with any body
	CreatePresetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePreset(ctx context.Context, body CreatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePresetWithBody request with any body
	UpdatePresetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePreset(ctx context.Context, body UpdatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePreset request
	DeletePreset(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebSocketClients(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebSocketClientsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameServers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameServersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGameServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGameServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGameServer(ctx context.Context, body CreateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGameServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGameServer(ctx context.Context, ip string, port float64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGameServerRequest(c.Server, ip, port)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGameServerWithBody(ctx context.Context, ip string, port float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGameServerRequestWithBody(c.Server, ip, port, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGameServer(ctx context.Context, ip string, port float64, body UpdateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGameServerRequest(c.Server, ip, port, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllMatches(ctx context.Context, params *GetAllMatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllMatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMatch(ctx context.Context, body CreateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMatchRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMatchRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMatchWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMatch(ctx context.Context, id string, body UpdateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMatchRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogs(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMatchMapWithBody(ctx context.Context, id string, mapNumber float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMatchMapRequestWithBody(c.Server, id, mapNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMatchMap(ctx context.Context, id string, mapNumber float64, body UpdateMatchMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMatchMapRequest(c.Server, id, mapNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviveMatch(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviveMatchRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveLogWithBody(ctx context.Context, id string, secret string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveLogRequestWithBody(c.Server, id, secret, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveLog(ctx context.Context, id string, secret string, body ReceiveLogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveLogRequest(c.Server, id, secret, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RconWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRconRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Rcon(ctx context.Context, id string, body RconJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRconRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoundBackups(ctx context.Context, id string, params *GetRoundBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoundBackupsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadRoundBackup(ctx context.Context, id string, file string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadRoundBackupRequest(c.Server, id, file)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPresets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPresetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePresetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePreset(ctx context.Context, body CreatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePresetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePresetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreset(ctx context.Context, body UpdatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePresetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePreset(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePresetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfosRequest generates requests for GetInfos
func NewGetInfosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/debug")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebSocketClientsRequest generates requests for GetWebSocketClients
func NewGetWebSocketClientsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/debug/webSockets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameServersRequest generates requests for GetGameServers
func NewGetGameServersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/gameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGameServerRequest calls the generic CreateGameServer builder with application/json body
func NewCreateGameServerRequest(server string, body CreateGameServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGameServerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGameServerRequestWithBody generates requests for CreateGameServer with any type of body
func NewCreateGameServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/gameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGameServerRequest generates requests for DeleteGameServer
func NewDeleteGameServerRequest(server string, ip string, port float64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip", runtime.ParamLocationPath, ip)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/gameservers/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGameServerRequest calls the generic UpdateGameServer builder with application/json body
func NewUpdateGameServerRequest(server string, ip string, port float64, body UpdateGameServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGameServerRequestWithBody(server, ip, port, "application/json", bodyReader)
}

// NewUpdateGameServerRequestWithBody generates requests for UpdateGameServer with any type of body
func NewUpdateGameServerRequestWithBody(server string, ip string, port float64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip", runtime.ParamLocationPath, ip)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "port", runtime.ParamLocationPath, port)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/gameservers/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoginRequest generates requests for Login
func NewLoginRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllMatchesRequest generates requests for GetAllMatches
func NewGetAllMatchesRequest(server string, params *GetAllMatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Passthrough != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passthrough", runtime.ParamLocationQuery, *params.Passthrough); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsStopped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isStopped", runtime.ParamLocationQuery, *params.IsStopped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isLive", runtime.ParamLocationQuery, *params.IsLive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMatchRequest calls the generic CreateMatch builder with application/json body
func NewCreateMatchRequest(server string, body CreateMatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMatchRequestWithBody generates requests for CreateMatch with any type of body
func NewCreateMatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMatchRequest generates requests for DeleteMatch
func NewDeleteMatchRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMatchRequest generates requests for GetMatch
func NewGetMatchRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMatchRequest calls the generic UpdateMatch builder with application/json body
func NewUpdateMatchRequest(server string, id string, body UpdateMatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMatchRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateMatchRequestWithBody generates requests for UpdateMatch with any type of body
func NewUpdateMatchRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogsRequest generates requests for GetLogs
func NewGetLogsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMatchMapRequest calls the generic UpdateMatchMap builder with application/json body
func NewUpdateMatchMapRequest(server string, id string, mapNumber float64, body UpdateMatchMapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMatchMapRequestWithBody(server, id, mapNumber, "application/json", bodyReader)
}

// NewUpdateMatchMapRequestWithBody generates requests for UpdateMatchMap with any type of body
func NewUpdateMatchMapRequestWithBody(server string, id string, mapNumber float64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "mapNumber", runtime.ParamLocationPath, mapNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/matchMap/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReviveMatchRequest generates requests for ReviveMatch
func NewReviveMatchRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/revive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiveLogRequest calls the generic ReceiveLog builder with application/json body
func NewReceiveLogRequest(server string, id string, secret string, body ReceiveLogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReceiveLogRequestWithBody(server, id, secret, "application/json", bodyReader)
}

// NewReceiveLogRequestWithBody generates requests for ReceiveLog with any type of body
func NewReceiveLogRequestWithBody(server string, id string, secret string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret", runtime.ParamLocationPath, secret)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/server/log/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRconRequest calls the generic Rcon builder with application/json body
func NewRconRequest(server string, id string, body RconJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRconRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRconRequestWithBody generates requests for Rcon with any type of body
func NewRconRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/server/rcon", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRoundBackupsRequest generates requests for GetRoundBackups
func NewGetRoundBackupsRequest(server string, id string, params *GetRoundBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/server/round_backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadRoundBackupRequest generates requests for LoadRoundBackup
func NewLoadRoundBackupRequest(server string, id string, file string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "file", runtime.ParamLocationPath, file)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/matches/%s/server/round_backups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPresetsRequest generates requests for GetPresets
func NewGetPresetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/presets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePresetRequest calls the generic CreatePreset builder with application/json body
func NewCreatePresetRequest(server string, body CreatePresetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePresetRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePresetRequestWithBody generates requests for CreatePreset with any type of body
func NewCreatePresetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/presets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePresetRequest calls the generic UpdatePreset builder with application/json body
func NewUpdatePresetRequest(server string, body UpdatePresetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePresetRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdatePresetRequestWithBody generates requests for UpdatePreset with any type of body
func NewUpdatePresetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/presets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePresetRequest generates requests for DeletePreset
func NewDeletePresetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/presets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetInfosWithResponse request
	GetInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfosResponse, error)

	// GetWebSocketClientsWithResponse request
	GetWebSocketClientsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebSocketClientsResponse, error)

	// GetGameServersWithResponse request
	GetGameServersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGameServersResponse, error)

	// CreateGameServerWithBodyWithResponse request with any body
	CreateGameServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGameServerResponse, error)

	CreateGameServerWithResponse(ctx context.Context, body CreateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGameServerResponse, error)

	// DeleteGameServerWithResponse request
	DeleteGameServerWithResponse(ctx context.Context, ip string, port float64, reqEditors ...RequestEditorFn) (*DeleteGameServerResponse, error)

	// UpdateGameServerWithBodyWithResponse request with any body
	UpdateGameServerWithBodyWithResponse(ctx context.Context, ip string, port float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGameServerResponse, error)

	UpdateGameServerWithResponse(ctx context.Context, ip string, port float64, body UpdateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGameServerResponse, error)

	// LoginWithResponse request
	LoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// GetAllMatchesWithResponse request
	GetAllMatchesWithResponse(ctx context.Context, params *GetAllMatchesParams, reqEditors ...RequestEditorFn) (*GetAllMatchesResponse, error)

	// CreateMatchWithBodyWithResponse request with any body
	CreateMatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMatchResponse, error)

	CreateMatchWithResponse(ctx context.Context, body CreateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMatchResponse, error)

	// DeleteMatchWithResponse request
	DeleteMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMatchResponse, error)

	// GetMatchWithResponse request
	GetMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMatchResponse, error)

	// UpdateMatchWithBodyWithResponse request with any body
	UpdateMatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMatchResponse, error)

	UpdateMatchWithResponse(ctx context.Context, id string, body UpdateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMatchResponse, error)

	// GetEventsWithResponse request
	GetEventsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)

	// GetLogsWithResponse request
	GetLogsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogsResponse, error)

	// UpdateMatchMapWithBodyWithResponse request with any body
	UpdateMatchMapWithBodyWithResponse(ctx context.Context, id string, mapNumber float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMatchMapResponse, error)

	UpdateMatchMapWithResponse(ctx context.Context, id string, mapNumber float64, body UpdateMatchMapJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMatchMapResponse, error)

	// ReviveMatchWithResponse request
	ReviveMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReviveMatchResponse, error)

	// ReceiveLogWithBodyWithResponse request with any body
	ReceiveLogWithBodyWithResponse(ctx context.Context, id string, secret string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveLogResponse, error)

	ReceiveLogWithResponse(ctx context.Context, id string, secret string, body ReceiveLogJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveLogResponse, error)

	// RconWithBodyWithResponse request with any body
	RconWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RconResponse, error)

	RconWithResponse(ctx context.Context, id string, body RconJSONRequestBody, reqEditors ...RequestEditorFn) (*RconResponse, error)

	// GetRoundBackupsWithResponse request
	GetRoundBackupsWithResponse(ctx context.Context, id string, params *GetRoundBackupsParams, reqEditors ...RequestEditorFn) (*GetRoundBackupsResponse, error)

	// LoadRoundBackupWithResponse request
	LoadRoundBackupWithResponse(ctx context.Context, id string, file string, reqEditors ...RequestEditorFn) (*LoadRoundBackupResponse, error)

	// GetPresetsWithResponse request
	GetPresetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPresetsResponse, error)

	// CreatePresetWithBodyWithResponse request with any body
	CreatePresetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePresetResponse, error)

	CreatePresetWithResponse(ctx context.Context, body CreatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePresetResponse, error)

	// UpdatePresetWithBodyWithResponse request with any body
	UpdatePresetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePresetResponse, error)

	UpdatePresetWithResponse(ctx context.Context, body UpdatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePresetResponse, error)

	// DeletePresetWithResponse request
	DeletePresetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePresetResponse, error)
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IConfig
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TmtLogAddress    string        `json:"tmtLogAddress"`
		TmtPort          int           `json:"tmtPort"`
		TmtSayPrefix     string        `json:"tmtSayPrefix"`
		TmtStorageFolder string        `json:"tmtStorageFolder"`
		TmtVersion       string        `json:"tmtVersion"`
		WebSockets       []interface{} `json:"webSockets"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInfosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebSocketClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]interface{}
}

// Status returns HTTPResponse.Status
func (r GetWebSocketClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebSocketClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IManagedGameServer
}

// Status returns HTTPResponse.Status
func (r GetGameServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGameServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IManagedGameServer
}

// Status returns HTTPResponse.Status
func (r CreateGameServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGameServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGameServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGameServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGameServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGameServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IManagedGameServer
}

// Status returns HTTPResponse.Status
func (r UpdateGameServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGameServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllMatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IMatchResponse
}

// Status returns HTTPResponse.Status
func (r GetAllMatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllMatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IMatch
}

// Status returns HTTPResponse.Status
func (r CreateMatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r GetMatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMatchMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateMatchMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMatchMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviveMatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReviveMatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviveMatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReceiveLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RconResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r RconResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RconResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoundBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r GetRoundBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoundBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadRoundBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r LoadRoundBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadRoundBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPresetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IPreset
}

// Status returns HTTPResponse.Status
func (r GetPresetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPresetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePresetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IPreset
}

// Status returns HTTPResponse.Status
func (r CreatePresetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePresetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePresetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePresetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePresetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePresetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePresetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePresetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetInfosWithResponse request returning *GetInfosResponse
func (c *ClientWithResponses) GetInfosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfosResponse, error) {
	rsp, err := c.GetInfos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfosResponse(rsp)
}

// GetWebSocketClientsWithResponse request returning *GetWebSocketClientsResponse
func (c *ClientWithResponses) GetWebSocketClientsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWebSocketClientsResponse, error) {
	rsp, err := c.GetWebSocketClients(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebSocketClientsResponse(rsp)
}

// GetGameServersWithResponse request returning *GetGameServersResponse
func (c *ClientWithResponses) GetGameServersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGameServersResponse, error) {
	rsp, err := c.GetGameServers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGameServersResponse(rsp)
}

// CreateGameServerWithBodyWithResponse request with arbitrary body returning *CreateGameServerResponse
func (c *ClientWithResponses) CreateGameServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGameServerResponse, error) {
	rsp, err := c.CreateGameServerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGameServerResponse(rsp)
}

func (c *ClientWithResponses) CreateGameServerWithResponse(ctx context.Context, body CreateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGameServerResponse, error) {
	rsp, err := c.CreateGameServer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGameServerResponse(rsp)
}

// DeleteGameServerWithResponse request returning *DeleteGameServerResponse
func (c *ClientWithResponses) DeleteGameServerWithResponse(ctx context.Context, ip string, port float64, reqEditors ...RequestEditorFn) (*DeleteGameServerResponse, error) {
	rsp, err := c.DeleteGameServer(ctx, ip, port, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGameServerResponse(rsp)
}

// UpdateGameServerWithBodyWithResponse request with arbitrary body returning *UpdateGameServerResponse
func (c *ClientWithResponses) UpdateGameServerWithBodyWithResponse(ctx context.Context, ip string, port float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGameServerResponse, error) {
	rsp, err := c.UpdateGameServerWithBody(ctx, ip, port, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGameServerResponse(rsp)
}

func (c *ClientWithResponses) UpdateGameServerWithResponse(ctx context.Context, ip string, port float64, body UpdateGameServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGameServerResponse, error) {
	rsp, err := c.UpdateGameServer(ctx, ip, port, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGameServerResponse(rsp)
}

// LoginWithResponse request returning *LoginResponse
func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// GetAllMatchesWithResponse request returning *GetAllMatchesResponse
func (c *ClientWithResponses) GetAllMatchesWithResponse(ctx context.Context, params *GetAllMatchesParams, reqEditors ...RequestEditorFn) (*GetAllMatchesResponse, error) {
	rsp, err := c.GetAllMatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllMatchesResponse(rsp)
}

// CreateMatchWithBodyWithResponse request with arbitrary body returning *CreateMatchResponse
func (c *ClientWithResponses) CreateMatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMatchResponse, error) {
	rsp, err := c.CreateMatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMatchResponse(rsp)
}

func (c *ClientWithResponses) CreateMatchWithResponse(ctx context.Context, body CreateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMatchResponse, error) {
	rsp, err := c.CreateMatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMatchResponse(rsp)
}

// DeleteMatchWithResponse request returning *DeleteMatchResponse
func (c *ClientWithResponses) DeleteMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteMatchResponse, error) {
	rsp, err := c.DeleteMatch(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMatchResponse(rsp)
}

// GetMatchWithResponse request returning *GetMatchResponse
func (c *ClientWithResponses) GetMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetMatchResponse, error) {
	rsp, err := c.GetMatch(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMatchResponse(rsp)
}

// UpdateMatchWithBodyWithResponse request with arbitrary body returning *UpdateMatchResponse
func (c *ClientWithResponses) UpdateMatchWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMatchResponse, error) {
	rsp, err := c.UpdateMatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateMatchWithResponse(ctx context.Context, id string, body UpdateMatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMatchResponse, error) {
	rsp, err := c.UpdateMatch(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMatchResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// GetLogsWithResponse request returning *GetLogsResponse
func (c *ClientWithResponses) GetLogsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogsResponse, error) {
	rsp, err := c.GetLogs(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsResponse(rsp)
}

// UpdateMatchMapWithBodyWithResponse request with arbitrary body returning *UpdateMatchMapResponse
func (c *ClientWithResponses) UpdateMatchMapWithBodyWithResponse(ctx context.Context, id string, mapNumber float64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMatchMapResponse, error) {
	rsp, err := c.UpdateMatchMapWithBody(ctx, id, mapNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMatchMapResponse(rsp)
}

func (c *ClientWithResponses) UpdateMatchMapWithResponse(ctx context.Context, id string, mapNumber float64, body UpdateMatchMapJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMatchMapResponse, error) {
	rsp, err := c.UpdateMatchMap(ctx, id, mapNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMatchMapResponse(rsp)
}

// ReviveMatchWithResponse request returning *ReviveMatchResponse
func (c *ClientWithResponses) ReviveMatchWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReviveMatchResponse, error) {
	rsp, err := c.ReviveMatch(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviveMatchResponse(rsp)
}

// ReceiveLogWithBodyWithResponse request with arbitrary body returning *ReceiveLogResponse
func (c *ClientWithResponses) ReceiveLogWithBodyWithResponse(ctx context.Context, id string, secret string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveLogResponse, error) {
	rsp, err := c.ReceiveLogWithBody(ctx, id, secret, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveLogResponse(rsp)
}

func (c *ClientWithResponses) ReceiveLogWithResponse(ctx context.Context, id string, secret string, body ReceiveLogJSONRequestBody, reqEditors ...RequestEditorFn) (*ReceiveLogResponse, error) {
	rsp, err := c.ReceiveLog(ctx, id, secret, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveLogResponse(rsp)
}

// RconWithBodyWithResponse request with arbitrary body returning *RconResponse
func (c *ClientWithResponses) RconWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RconResponse, error) {
	rsp, err := c.RconWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRconResponse(rsp)
}

func (c *ClientWithResponses) RconWithResponse(ctx context.Context, id string, body RconJSONRequestBody, reqEditors ...RequestEditorFn) (*RconResponse, error) {
	rsp, err := c.Rcon(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRconResponse(rsp)
}

// GetRoundBackupsWithResponse request returning *GetRoundBackupsResponse
func (c *ClientWithResponses) GetRoundBackupsWithResponse(ctx context.Context, id string, params *GetRoundBackupsParams, reqEditors ...RequestEditorFn) (*GetRoundBackupsResponse, error) {
	rsp, err := c.GetRoundBackups(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoundBackupsResponse(rsp)
}

// LoadRoundBackupWithResponse request returning *LoadRoundBackupResponse
func (c *ClientWithResponses) LoadRoundBackupWithResponse(ctx context.Context, id string, file string, reqEditors ...RequestEditorFn) (*LoadRoundBackupResponse, error) {
	rsp, err := c.LoadRoundBackup(ctx, id, file, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadRoundBackupResponse(rsp)
}

// GetPresetsWithResponse request returning *GetPresetsResponse
func (c *ClientWithResponses) GetPresetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPresetsResponse, error) {
	rsp, err := c.GetPresets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPresetsResponse(rsp)
}

// CreatePresetWithBodyWithResponse request with arbitrary body returning *CreatePresetResponse
func (c *ClientWithResponses) CreatePresetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePresetResponse, error) {
	rsp, err := c.CreatePresetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresetResponse(rsp)
}

func (c *ClientWithResponses) CreatePresetWithResponse(ctx context.Context, body CreatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePresetResponse, error) {
	rsp, err := c.CreatePreset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresetResponse(rsp)
}

// UpdatePresetWithBodyWithResponse request with arbitrary body returning *UpdatePresetResponse
func (c *ClientWithResponses) UpdatePresetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePresetResponse, error) {
	rsp, err := c.UpdatePresetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePresetResponse(rsp)
}

func (c *ClientWithResponses) UpdatePresetWithResponse(ctx context.Context, body UpdatePresetJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePresetResponse, error) {
	rsp, err := c.UpdatePreset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePresetResponse(rsp)
}

// DeletePresetWithResponse request returning *DeletePresetResponse
func (c *ClientWithResponses) DeletePresetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeletePresetResponse, error) {
	rsp, err := c.DeletePreset(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePresetResponse(rsp)
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInfosResponse parses an HTTP response from a GetInfosWithResponse call
func ParseGetInfosResponse(rsp *http.Response) (*GetInfosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TmtLogAddress    string        `json:"tmtLogAddress"`
			TmtPort          int           `json:"tmtPort"`
			TmtSayPrefix     string        `json:"tmtSayPrefix"`
			TmtStorageFolder string        `json:"tmtStorageFolder"`
			TmtVersion       string        `json:"tmtVersion"`
			WebSockets       []interface{} `json:"webSockets"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebSocketClientsResponse parses an HTTP response from a GetWebSocketClientsWithResponse call
func ParseGetWebSocketClientsResponse(rsp *http.Response) (*GetWebSocketClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebSocketClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGameServersResponse parses an HTTP response from a GetGameServersWithResponse call
func ParseGetGameServersResponse(rsp *http.Response) (*GetGameServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGameServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IManagedGameServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGameServerResponse parses an HTTP response from a CreateGameServerWithResponse call
func ParseCreateGameServerResponse(rsp *http.Response) (*CreateGameServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGameServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IManagedGameServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGameServerResponse parses an HTTP response from a DeleteGameServerWithResponse call
func ParseDeleteGameServerResponse(rsp *http.Response) (*DeleteGameServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGameServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGameServerResponse parses an HTTP response from a UpdateGameServerWithResponse call
func ParseUpdateGameServerResponse(rsp *http.Response) (*UpdateGameServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGameServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IManagedGameServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAllMatchesResponse parses an HTTP response from a GetAllMatchesWithResponse call
func ParseGetAllMatchesResponse(rsp *http.Response) (*GetAllMatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllMatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IMatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateMatchResponse parses an HTTP response from a CreateMatchWithResponse call
func ParseCreateMatchResponse(rsp *http.Response) (*CreateMatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IMatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteMatchResponse parses an HTTP response from a DeleteMatchWithResponse call
func ParseDeleteMatchResponse(rsp *http.Response) (*DeleteMatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetMatchResponse parses an HTTP response from a GetMatchWithResponse call
func ParseGetMatchResponse(rsp *http.Response) (*GetMatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateMatchResponse parses an HTTP response from a UpdateMatchWithResponse call
func ParseUpdateMatchResponse(rsp *http.Response) (*UpdateMatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLogsResponse parses an HTTP response from a GetLogsWithResponse call
func ParseGetLogsResponse(rsp *http.Response) (*GetLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateMatchMapResponse parses an HTTP response from a UpdateMatchMapWithResponse call
func ParseUpdateMatchMapResponse(rsp *http.Response) (*UpdateMatchMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMatchMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReviveMatchResponse parses an HTTP response from a ReviveMatchWithResponse call
func ParseReviveMatchResponse(rsp *http.Response) (*ReviveMatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviveMatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReceiveLogResponse parses an HTTP response from a ReceiveLogWithResponse call
func ParseReceiveLogResponse(rsp *http.Response) (*ReceiveLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRconResponse parses an HTTP response from a RconWithResponse call
func ParseRconResponse(rsp *http.Response) (*RconResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RconResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRoundBackupsResponse parses an HTTP response from a GetRoundBackupsWithResponse call
func ParseGetRoundBackupsResponse(rsp *http.Response) (*GetRoundBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoundBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadRoundBackupResponse parses an HTTP response from a LoadRoundBackupWithResponse call
func ParseLoadRoundBackupResponse(rsp *http.Response) (*LoadRoundBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadRoundBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPresetsResponse parses an HTTP response from a GetPresetsWithResponse call
func ParseGetPresetsResponse(rsp *http.Response) (*GetPresetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPresetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IPreset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePresetResponse parses an HTTP response from a CreatePresetWithResponse call
func ParseCreatePresetResponse(rsp *http.Response) (*CreatePresetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePresetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IPreset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdatePresetResponse parses an HTTP response from a UpdatePresetWithResponse call
func ParseUpdatePresetResponse(rsp *http.Response) (*UpdatePresetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePresetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePresetResponse parses an HTTP response from a DeletePresetWithResponse call
func ParseDeletePresetResponse(rsp *http.Response) (*DeletePresetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePresetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
